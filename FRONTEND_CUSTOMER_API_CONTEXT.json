{
  "metadata": {
    "title": "Frontend Customer API Context",
    "description": "Customer-facing (user website) integration guide for Coffee Shop Backend APIs. Focus on read-only features for catalog browsing.",
    "baseUrls": {
      "development": "http://localhost:3000",
      "production": "<set-your-production-base-url>"
    },
  "swagger": "http://localhost:3000/api/docs",
    "auth": "Not required for public catalog endpoints"
  },

  "enums": {
    "ProductStatus": {
      "ACTIVE": "active",
      "INACTIVE": "inactive"
    }
  },

  "types": {
    "Category.ts": "export interface Category { id: number; name: string; description?: string | null; }",
    "Product.ts": "export interface Product { id: number; name: string; description?: string | null; price: number; image?: string | null; status: 'active'|'inactive'; categoryId: number; category: Category; }",
    "ApiListResponse.ts": "export type CategoryList = Category[]; export type ProductList = Product[];"
  },

  "endpoints": [
    {
      "name": "List Categories",
      "method": "GET",
      "url": "/categories",
      "description": "Returns all categories.",
      "params": {},
      "responseExample": [
        { "id": 1, "name": "Coffee", "description": "Espresso, Americano, …" },
        { "id": 2, "name": "Tea", "description": null }
      ],
      "tsReturnType": "Category[]",
      "errors": [ { "status": 500, "message": "Server error" } ],
      "usage": {
        "fetch": "const res = await fetch(baseUrl + '/categories'); const data = await res.json();",
        "axios": "const { data } = await axios.get(baseUrl + '/categories');"
      }
    },
    {
      "name": "Get Category by ID",
      "method": "GET",
      "url": "/categories/:id",
      "description": "Returns a single category by ID.",
      "params": { "path": { "id": "number" } },
      "responseExample": { "id": 1, "name": "Coffee", "description": "Espresso, Americano, …" },
      "tsReturnType": "Category",
      "errors": [ { "status": 404, "message": "Category not found" } ],
      "usage": {
        "fetch": "const res = await fetch(baseUrl + '/categories/' + id); const data = await res.json();",
        "axios": "const { data } = await axios.get(baseUrl + '/categories/' + id);"
      }
    },
    {
      "name": "List Products (optional filter by category)",
      "method": "GET",
      "url": "/products",
      "description": "Returns products. Optional query param 'categoryId' filters by category. Includes 'category' object (eager loaded). Does not filter by status on backend — filter client-side to show only 'active'.",
      "params": { "query": { "categoryId?": "number" } },
      "responseExample": [
        {
          "id": 10,
          "name": "Cappuccino",
          "description": "Espresso with steamed milk and foam",
          "price": 45000,
          "image": "uploads/1699999999-abc123-cappuccino.jpg",
          "status": "active",
          "categoryId": 1,
          "category": { "id": 1, "name": "Coffee", "description": "Espresso, Americano, …" }
        }
      ],
      "tsReturnType": "Product[]",
      "errors": [ { "status": 500, "message": "Server error" } ],
      "usage": {
        "fetch": "const url = new URL(baseUrl + '/products'); if (categoryId) url.searchParams.set('categoryId', String(categoryId)); const res = await fetch(url); const data = await res.json();",
        "axios": "const { data } = await axios.get(baseUrl + '/products', { params: { categoryId } });"
      }
    },
    {
      "name": "Get Product by ID",
      "method": "GET",
      "url": "/products/:id",
      "description": "Returns a single product by ID (includes 'category').",
      "params": { "path": { "id": "number" } },
      "responseExample": {
        "id": 10,
        "name": "Cappuccino",
        "description": "Espresso with steamed milk and foam",
        "price": 45000,
        "image": "uploads/1699999999-abc123-cappuccino.jpg",
        "status": "active",
        "categoryId": 1,
        "category": { "id": 1, "name": "Coffee", "description": "Espresso, Americano, …" }
      },
      "tsReturnType": "Product",
      "errors": [ { "status": 404, "message": "Product not found" } ],
      "usage": {
        "fetch": "const res = await fetch(baseUrl + '/products/' + id); const data = await res.json();",
        "axios": "const { data } = await axios.get(baseUrl + '/products/' + id);"
      }
    },
    {
      "name": "Serve Product Image",
      "method": "GET",
      "url": "/uploads/{filename}",
      "description": "Static file serving for uploaded images. Build URL using product.image relative path.",
      "params": { "path": { "filename": "string" } },
      "responseExample": "<binary image>",
      "usage": {
        "urlBuild": "const imageUrl = baseUrl + '/' + product.image; // e.g. http://localhost:3000/uploads/xxxx.jpg"
      }
    }
  ],

  "workflows": {
    "fetchAndDisplayCategories": {
      "steps": [
        "GET /categories",
        "Render category list (name) with click handler to filter products"
      ],
      "example": "const categories = await api.getCategories(); setCategories(categories);"
    },
    "fetchAndDisplayCatalog": {
      "steps": [
        "GET /products (optionally with ?categoryId)",
        "Client-side filter to include only status==='active'",
        "Build image URL: baseUrl + '/' + product.image"
      ],
      "example": "const products = (await api.getProducts({ categoryId })).filter(p => p.status==='active');"
    },
    "displayProductDetails": {
      "steps": [
        "GET /products/:id",
        "Show name, price, description, category.name, image"
      ]
    },
    "productStatusHandling": {
      "rule": "Customer UI should hide inactive products (status!=='active').",
      "note": "Backend does not currently filter by status for GET /products."
    }
  },

  "apiServiceExamples.ts": {
    "notes": "Minimal API service using fetch or axios. Replace baseUrl accordingly.",
    "fetch": "export const baseUrl = 'http://localhost:3000';\nexport async function getCategories() { const r = await fetch(baseUrl + '/categories'); return r.json(); }\nexport async function getProducts(p?: { categoryId?: number }) { const u = new URL(baseUrl + '/products'); if (p?.categoryId) u.searchParams.set('categoryId', String(p.categoryId)); const r = await fetch(u); return r.json(); }\nexport async function getProduct(id: number) { const r = await fetch(baseUrl + '/products/' + id); return r.json(); }\nexport function buildImageUrl(relPath?: string | null) { return relPath ? baseUrl + '/' + relPath : ''; }",
    "axios": "import axios from 'axios';\nexport const baseUrl = 'http://localhost:3000';\nexport async function getCategories() { const { data } = await axios.get(baseUrl + '/categories'); return data; }\nexport async function getProducts(p?: { categoryId?: number }) { const { data } = await axios.get(baseUrl + '/products', { params: { categoryId: p?.categoryId } }); return data; }\nexport async function getProduct(id: number) { const { data } = await axios.get(baseUrl + '/products/' + id); return data; }\nexport function buildImageUrl(relPath?: string | null) { return relPath ? baseUrl + '/' + relPath : ''; }"
  },

  "reactExamples": {
    "CategoriesList.tsx": "import React, { useEffect, useState } from 'react';\nimport { getCategories } from './api';\nexport const CategoriesList: React.FC<{ onSelect: (id?: number)=>void }> = ({ onSelect }) => { const [cats, setCats] = useState([] as any[]); useEffect(() => { getCategories().then(setCats); }, []); return (<ul>{cats.map(c => (<li key={c.id}><button onClick={()=>onSelect(c.id)}>{c.name}</button></li>))}<li><button onClick={()=>onSelect(undefined)}>All</button></li></ul>); };",
    "ProductGrid.tsx": "import React, { useEffect, useState } from 'react';\nimport { getProducts, buildImageUrl } from './api';\nexport const ProductGrid: React.FC<{ categoryId?: number }> = ({ categoryId }) => { const [items, setItems] = useState([] as any[]); useEffect(() => { getProducts({ categoryId }).then(p => setItems(p.filter((x:any)=>x.status==='active'))); }, [categoryId]); return (<div style={{display:'grid',gridTemplateColumns:'repeat(3,1fr)',gap:16}}>{items.map(p => (<div key={p.id}><img alt={p.name} src={buildImageUrl(p.image)} style={{width:'100%',height:160,objectFit:'cover'}}/><h4>{p.name}</h4><div>{p.category?.name}</div><strong>{Number(p.price).toLocaleString() + ' \u20ab'}</strong><p>{p.description}</p></div>))}</div>); };",
    "ProductDetail.tsx": "import React, { useEffect, useState } from 'react';\nimport { getProduct, buildImageUrl } from './api';\nexport const ProductDetail: React.FC<{ id: number }> = ({ id }) => { const [p,setP]=useState<any>(null); useEffect(()=>{ getProduct(id).then(setP); },[id]); if(!p) return null; return (<article><img alt={p.name} src={buildImageUrl(p.image)} style={{maxWidth:400}}/><h2>{p.name}</h2><div>{p.category?.name}</div><strong>{Number(p.price).toLocaleString() + ' \u20ab'}</strong><p>{p.description}</p></article>); };"
  },

  "errorResponses": [
    { "status": 400, "when": "Invalid ID in path param (categories/:id, products/:id)", "handling": "Show friendly message and redirect or go back" },
    { "status": 404, "when": "Resource not found (category or product)", "handling": "Show Not Found UI" },
    { "status": 500, "when": "Unexpected server error", "handling": "Show retry option and contact support if persists" },
    { "status": 0, "when": "Network error / CORS", "handling": "Check baseUrl and server status" }
  ],

  "relationships": {
    "productToCategory": "Product has categoryId and includes 'category' object (eager). Display product.category.name.",
    "productToImage": "Product.image stores relative path (e.g., 'uploads/..'). Build URL as baseUrl + '/' + product.image.",
    "status": "Only show products where status==='active' on customer UI."
  },

  "qaChecklist": [
    "Products list shows only active items",
    "Category filter updates product list",
    "Images render with correct base URL",
    "Product detail page shows category name",
    "Graceful handling for 404 product/category",
    "Loading and error states covered"
  ],
  "notes": [
    "Price field may arrive as a string from PostgreSQL/TypeORM decimal; cast with Number(product.price)",
    "Images are served from /uploads; product.image stores a relative path like 'uploads/...'"
  ]
}

